# =============================================================================
# ğŸŸ¡ GITHUB ACTIONS CD WORKFLOW (Continuous Deployment)
# =============================================================================
name: CD Pipeline

# =============================================================================
# TRIGGERS - Same as CI, but only deploys on main
# =============================================================================
on: 
  push:
    branches: 
      - main

  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default:  'latest'
        type:  string

# =============================================================================
# GLOBAL ENV
# =============================================================================
env: 
  DEPLOY_PATH: '/opt/app'
  CONTAINER_NAME: 'ecommerce-frontend'
  HOST_PORT: '3000'
  CONTAINER_PORT: '80'

# =============================================================================
# JOBS
# =============================================================================
jobs: 

  # ===========================================================================
  # JOB 1: WAIT FOR CI TO COMPLETE
  # ===========================================================================
  wait-for-ci:
    name: â³ Wait for CI Pipeline
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name:  â³ Wait for CI to Build & Push Image
        run: |
          echo "â³ Waiting 180 seconds for CI pipeline to complete..."
          echo "   CI needs to:  build image â†’ push to Docker Hub"
          sleep 180
          echo "âœ… Proceeding with deployment"

  # ===========================================================================
  # JOB 2: DEPLOY TO EC2
  # ===========================================================================
  deploy: 
    name: ğŸš€ Deploy to EC2
    runs-on: ubuntu-latest
    needs: wait-for-ci
    if: always() && (needs.wait-for-ci.result == 'success' || github.event_name == 'workflow_dispatch')

    outputs:
      deployed_tag: ${{ github.event.inputs.image_tag || 'latest' }}

    steps:
      - name: ğŸ”‘ Setup SSH
        run: |
          mkdir -p "$HOME/.ssh"
          echo "${{ secrets.EC2_SSH_KEY }}" > "$HOME/.ssh/deploy_key"
          chmod 600 "$HOME/.ssh/deploy_key"
          ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> "$HOME/.ssh/known_hosts" 2>/dev/null || true

      - name: ğŸš€ Deploy Application
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          DOCKER_REPO:  ${{ vars.DOCKER_REPO_FRONTEND || 'ecommerce-frontend' }}
          IMAGE_TAG: 'latest'
          CONTAINER_NAME: 'ecommerce-frontend'
          HOST_PORT: '3000'
          CONTAINER_PORT: '80'
        run: |
          ssh -i "$HOME/.ssh/deploy_key" -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            "${EC2_USER}@${EC2_HOST}" << ENDSSH
              set -e

              echo "=========================================="
              echo "ğŸš€ Deployment Started"
              echo "=========================================="
              echo "Image: ${DOCKER_USERNAME}/${DOCKER_REPO}:${IMAGE_TAG}"
              echo "=========================================="

              # Login to Docker Hub
              echo "${DOCKER_PASSWORD}" | docker login -u "${DOCKER_USERNAME}" --password-stdin

              # Pull image from correct repository
              echo "ğŸ“¥ Pulling image..."
              docker pull "${DOCKER_USERNAME}/${DOCKER_REPO}:${IMAGE_TAG}"

              # Stop and remove existing container
              docker stop ${CONTAINER_NAME} 2>/dev/null || true
              docker rm ${CONTAINER_NAME} 2>/dev/null || true

              # Run new container
              docker run -d \
                --name ${CONTAINER_NAME} \
                --restart unless-stopped \
                -p ${HOST_PORT}:${CONTAINER_PORT} \
                "${DOCKER_USERNAME}/${DOCKER_REPO}:${IMAGE_TAG}"

              docker image prune -f

              echo "âœ… Deployment Complete"
          ENDSSH

      - name: ğŸ“‹ Deployment Summary
        run: |
          echo "### âœ… Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Server:** ${{ secrets.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "**Container:** ${{ env.CONTAINER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ github.event.inputs.image_tag || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Port:** ${{ env.HOST_PORT }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # JOB 3: HEALTH CHECK
  # ===========================================================================
  health-check:
    name: ğŸ¥ Health Check
    runs-on: ubuntu-latest
    needs: deploy

    steps:
      - name:  â³ Wait for Application Startup
        run: sleep 15

      - name: ğŸ¥ Check Application Health
        id: health
        run: |
          echo "ğŸ” Checking application health..."
          echo ""

          MAX_ATTEMPTS=5
          ATTEMPT=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT of $MAX_ATTEMPTS..."

            # Check port 3000 (direct container access)
            STATUS_3000=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 --max-time 30 \
              "http://${{ secrets.EC2_HOST }}:3000" 2>/dev/null || echo "000")

            echo "  â†’ Port 3000: HTTP $STATUS_3000"

            # Success if port returns 200, 301, or 302
            if [ "$STATUS_3000" = "200" ] || [ "$STATUS_3000" = "301" ] || [ "$STATUS_3000" = "302" ]; then
              echo ""
              echo "âœ… Application is healthy!"
              echo "healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            ATTEMPT=$((ATTEMPT + 1))
            sleep 10
          done

          echo ""
          echo "âŒ Health check failed after $MAX_ATTEMPTS attempts"
          echo "healthy=false" >> $GITHUB_OUTPUT
          exit 1

      - name: ğŸ“‹ Health Check Summary
        if: always()
        run: |
          echo "### ğŸ¥ Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.health.outputs.healthy }}" == "true" ]; then
            echo "âœ… **Status:** Healthy" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Status:** Unhealthy" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Endpoint:** http://${{ secrets.EC2_HOST }}:3000" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # JOB 4: ROLLBACK (Only on Health Check Failure)
  # ===========================================================================
  rollback:
    name: ğŸ”„ Rollback Deployment
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: failure() && needs.deploy.result == 'success'

    steps:
      - name:  ğŸ”‘ Setup SSH
        run: |
          mkdir -p "$HOME/.ssh"
          echo "${{ secrets.EC2_SSH_KEY }}" > "$HOME/.ssh/deploy_key"
          chmod 600 "$HOME/.ssh/deploy_key"
          ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> "$HOME/.ssh/known_hosts" 2>/dev/null || true

      - name: ğŸ”„ Execute Rollback
        env:
          EC2_HOST:  ${{ secrets.EC2_HOST }}
          EC2_USER:  ${{ secrets.EC2_USER }}
          DOCKER_USERNAME:  ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD:  ${{ secrets.DOCKER_PASSWORD }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          HOST_PORT: ${{ env.HOST_PORT }}
          CONTAINER_PORT: ${{ env.CONTAINER_PORT }}
        run: |
          ssh -i "$HOME/.ssh/deploy_key" -o StrictHostKeyChecking=no \
            "${EC2_USER}@${EC2_HOST}" << ENDSSH
              set -e

              echo "=========================================="
              echo "ğŸ”„ Rollback Started"
              echo "=========================================="

              # Get list of available image tags
              echo "ğŸ“‹ Available local images:"
              docker images "${DOCKER_USERNAME}/${CONTAINER_NAME}" --format "{{.Tag}}" | head -5

              # Find previous image (not 'latest')
              PREV_IMAGE=\$(docker images "${DOCKER_USERNAME}/${CONTAINER_NAME}" --format "{{.Repository}}:{{.Tag}}" | grep -v ": latest" | head -1)

              if [ -z "\$PREV_IMAGE" ]; then
                echo "âš ï¸ No previous image found, keeping current state"
                exit 0
              fi

              echo "ğŸ“¦ Rolling back to:  \$PREV_IMAGE"

              # Stop current container
              docker stop ${CONTAINER_NAME} 2>/dev/null || true
              docker rm ${CONTAINER_NAME} 2>/dev/null || true

              # Start with previous image
              docker run -d \
                --name ${CONTAINER_NAME} \
                --restart unless-stopped \
                -p ${HOST_PORT}:${CONTAINER_PORT} \
                "\$PREV_IMAGE"

              echo ""
              echo "=========================================="
              echo "âœ… Rollback Complete"
              echo "=========================================="
              docker ps --filter "name=${CONTAINER_NAME}"
          ENDSSH

      - name: ğŸ“‹ Rollback Summary
        run: |
          echo "### ğŸ”„ Rollback Executed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Reason:** Health check failed after deployment" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # JOB 5: NOTIFY DEPLOYMENT STATUS
  # ===========================================================================
  notify: 
    name: ğŸ“§ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: always() && needs.deploy.result == 'success'

    steps: 
      - name: ğŸ“§ Send Deployment Notification
        uses: dawidd6/action-send-mail@v3
        with: 
          server_address: ${{ secrets.SMTP_HOST }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "[CD] ${{ needs.health-check.result == 'success' && 'âœ… Deployment Successful' || 'âŒ Deployment Failed' }} - ${{ github.repository }}"
          to: ${{ secrets.TESTER_EMAIL }}
          from: "CD Bot <${{ secrets.SMTP_USERNAME }}>"
          body: |
            Hello Team,

            Deployment pipeline has completed. 

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ğŸ“‹ DEPLOYMENT DETAILS
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            ğŸ”¹ Status: ${{ needs.health-check.result == 'success' && 'âœ… SUCCESS' || 'âŒ FAILED' }}
            ğŸ”¹ Server: ${{ secrets.EC2_HOST }}
            ğŸ”¹ Application: ecommerce-frontend
            ğŸ”¹ Triggered by: ${{ github.actor }}

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ğŸ”— LINKS
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            ğŸŒ Application: http://${{ secrets.EC2_HOST }}:3000
            ğŸ”„ Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            Regards,
            CD Bot ğŸ¤–
        continue-on-error: true