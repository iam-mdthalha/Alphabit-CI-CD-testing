# =============================================================================
# ğŸŸ¡ GITHUB ACTIONS CD WORKFLOW (Continuous Deployment)
# =============================================================================
name: CD Pipeline

# =============================================================================
# TRIGGERS - Runs AFTER CI Pipeline completes on main branch
# =============================================================================
on: 
  workflow_run:
    workflows: ["CI Pipeline"]
    types: 
      - completed
    branches: 
      - main

  workflow_dispatch: 
    inputs:
      image_tag:
        description: 'Docker image tag to deploy (default: latest)'
        required: false
        default: 'latest'
        type: string

# =============================================================================
# GLOBAL ENV
# =============================================================================
env: 
  DEPLOY_PATH: '/opt/app'
  CONTAINER_NAME: 'ecommerce-frontend'
  HOST_PORT: '3000'
  CONTAINER_PORT: '80'

# =============================================================================
# JOBS
# =============================================================================
jobs: 

  # ===========================================================================
  # JOB 1: CHECK CI STATUS
  # ===========================================================================
  check-ci: 
    name: âœ… Verify CI Success
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      image_tag: ${{ steps.check.outputs.image_tag }}

    steps:
      - name:  ğŸ” Check CI Result
        id: check
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.event.inputs.image_tag || 'latest' }}" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Manual deployment triggered with tag: ${{ github.event. inputs.image_tag || 'latest' }}"
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "âœ… CI Pipeline succeeded, proceeding with deployment"
          fi

      - name: ğŸ“‹ Deployment Info
        run: |
          echo "### ğŸš€ Deployment Triggered" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ steps.check.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # JOB 2: DEPLOY TO EC2
  # ===========================================================================
  deploy: 
    name: ğŸš€ Deploy to EC2
    runs-on: ubuntu-latest
    needs: check-ci
    if: needs.check-ci.outputs.should_deploy == 'true'

    outputs:
      deployed_tag: ${{ needs.check-ci.outputs.image_tag }}
      run_number: ${{ github.run_number }}

    steps:
      - name: ğŸ”‘ Setup SSH
        run: |
          mkdir -p "$HOME/.ssh"
          echo "${{ secrets.EC2_SSH_KEY }}" > "$HOME/.ssh/deploy_key"
          chmod 600 "$HOME/.ssh/deploy_key"
          ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> "$HOME/.ssh/known_hosts" 2>/dev/null || true

      - name: ğŸš€ Deploy Application
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          IMAGE_TAG: ${{ needs.check-ci.outputs.image_tag }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          HOST_PORT: ${{ env.HOST_PORT }}
          CONTAINER_PORT: ${{ env.CONTAINER_PORT }}
        run:  |
          ssh -i "$HOME/.ssh/deploy_key" -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            "${EC2_USER}@${EC2_HOST}" << ENDSSH
              set -e

              echo "=========================================="
              echo "ğŸš€ Deployment Started"
              echo "=========================================="
              echo "Image:  ${DOCKER_USERNAME}/${CONTAINER_NAME}:${IMAGE_TAG}"
              echo "=========================================="

              # Login to Docker Hub
              echo "${DOCKER_PASSWORD}" | docker login -u "${DOCKER_USERNAME}" --password-stdin

              # Pull latest image
              echo "ğŸ“¥ Pulling image..."
              docker pull "${DOCKER_USERNAME}/${CONTAINER_NAME}:${IMAGE_TAG}"

              # Stop and remove existing container
              echo "ğŸ›‘ Stopping existing container..."
              docker stop ${CONTAINER_NAME} 2>/dev/null || true
              docker rm ${CONTAINER_NAME} 2>/dev/null || true

              # Run new container
              echo "ğŸ³ Starting new container..."
              docker run -d \
                --name ${CONTAINER_NAME} \
                --restart unless-stopped \
                -p ${HOST_PORT}:${CONTAINER_PORT} \
                "${DOCKER_USERNAME}/${CONTAINER_NAME}:${IMAGE_TAG}"

              # Cleanup old images
              docker image prune -f

              # Verify container is running
              echo ""
              echo "=========================================="
              echo "ğŸ“‹ Container Status"
              echo "=========================================="
              docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

              echo ""
              echo "=========================================="
              echo "âœ… Deployment Complete"
              echo "=========================================="
          ENDSSH

      - name: ğŸ“‹ Deployment Summary
        run:  |
          echo "### âœ… Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Server:** ${{ secrets.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "**Container:** ${{ env.CONTAINER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.check-ci.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Port:** ${{ env.HOST_PORT }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # JOB 3: HEALTH CHECK
  # ===========================================================================
  health-check:
    name: ğŸ¥ Health Check
    runs-on: ubuntu-latest
    needs: deploy

    steps:
      - name: â³ Wait for Application Startup
        run: sleep 15

      - name: ğŸ¥ Check Application Health
        id: health
        run: |
          echo "ğŸ” Checking application health..."
          echo ""

          MAX_ATTEMPTS=5
          ATTEMPT=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT of $MAX_ATTEMPTS..."

            # Check port 3000 (direct container access)
            STATUS_3000=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 --max-time 30 \
              "http://${{ secrets.EC2_HOST }}:3000" 2>/dev/null || echo "000")

            echo "  â†’ Port 3000: HTTP $STATUS_3000"

            # Check port 80 (through Nginx if configured)
            STATUS_80=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 --max-time 30 \
              "http://${{ secrets.EC2_HOST }}" 2>/dev/null || echo "000")

            echo "  â†’ Port 80: HTTP $STATUS_80"

            # Success if either port returns 200, 301, or 302
            if [ "$STATUS_3000" = "200" ] || [ "$STATUS_80" = "200" ] || \
               [ "$STATUS_3000" = "301" ] || [ "$STATUS_80" = "301" ] || \
               [ "$STATUS_3000" = "302" ] || [ "$STATUS_80" = "302" ]; then
              echo ""
              echo "âœ… Application is healthy!"
              echo "healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            ATTEMPT=$((ATTEMPT + 1))
            sleep 10
          done

          echo ""
          echo "âŒ Health check failed after $MAX_ATTEMPTS attempts"
          echo "healthy=false" >> $GITHUB_OUTPUT
          exit 1

      - name: ğŸ“‹ Health Check Summary
        if: always()
        run: |
          echo "### ğŸ¥ Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.health.outputs.healthy }}" == "true" ]; then
            echo "âœ… **Status:** Healthy" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Status:** Unhealthy" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Endpoints Checked:**" >> $GITHUB_STEP_SUMMARY
          echo "- http://${{ secrets.EC2_HOST }}:3000 (Direct)" >> $GITHUB_STEP_SUMMARY
          echo "- http://${{ secrets.EC2_HOST }} (Nginx)" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # JOB 4: ROLLBACK (Only on Health Check Failure)
  # ===========================================================================
  rollback:
    name: ğŸ”„ Rollback Deployment
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: failure() && needs.deploy.result == 'success'

    steps:
      - name: ğŸ”‘ Setup SSH
        run: |
          mkdir -p "$HOME/. ssh"
          echo "${{ secrets.EC2_SSH_KEY }}" > "$HOME/.ssh/deploy_key"
          chmod 600 "$HOME/.ssh/deploy_key"
          ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> "$HOME/.ssh/known_hosts" 2>/dev/null || true

      - name: ğŸ”„ Execute Rollback
        env:
          EC2_HOST:  ${{ secrets.EC2_HOST }}
          EC2_USER:  ${{ secrets.EC2_USER }}
          DOCKER_USERNAME:  ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD:  ${{ secrets.DOCKER_PASSWORD }}
          CONTAINER_NAME: ${{ env. CONTAINER_NAME }}
          HOST_PORT: ${{ env.HOST_PORT }}
          CONTAINER_PORT: ${{ env.CONTAINER_PORT }}
        run: |
          ssh -i "$HOME/. ssh/deploy_key" -o StrictHostKeyChecking=no \
            "${EC2_USER}@${EC2_HOST}" << ENDSSH
              set -e

              echo "=========================================="
              echo "ğŸ”„ Rollback Started"
              echo "=========================================="

              # Get list of available image tags
              echo "ğŸ“‹ Available local images:"
              docker images "${DOCKER_USERNAME}/${CONTAINER_NAME}" --format "{{.Tag}}" | head -5

              # Find previous image (not 'latest')
              PREV_IMAGE=\$(docker images "${DOCKER_USERNAME}/${CONTAINER_NAME}" --format "{{.Repository}}:{{.Tag}}" | grep -v ": latest" | head -1)

              if [ -z "\$PREV_IMAGE" ]; then
                echo "âŒ No previous image found for rollback"
                exit 1
              fi

              echo "ğŸ“¦ Rolling back to:  \$PREV_IMAGE"

              # Stop current container
              docker stop ${CONTAINER_NAME} 2>/dev/null || true
              docker rm ${CONTAINER_NAME} 2>/dev/null || true

              # Start with previous image
              docker run -d \
                --name ${CONTAINER_NAME} \
                --restart unless-stopped \
                -p ${HOST_PORT}:${CONTAINER_PORT} \
                "\$PREV_IMAGE"

              echo ""
              echo "=========================================="
              echo "âœ… Rollback Complete"
              echo "=========================================="
              docker ps --filter "name=${CONTAINER_NAME}"
          ENDSSH

      - name: ğŸ“‹ Rollback Summary
        run: |
          echo "### ğŸ”„ Rollback Executed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Reason:** Health check failed after deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The application has been rolled back to the previous working version." >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # JOB 5: NOTIFY DEPLOYMENT STATUS
  # ===========================================================================
  notify: 
    name: ğŸ“§ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: always()

    steps:
      - name: ğŸ“§ Send Deployment Notification
        uses: dawidd6/action-send-mail@v3
        with: 
          server_address: ${{ secrets.SMTP_HOST }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "[CD] ${{ needs.health-check.result == 'success' && 'âœ… Deployment Successful' || 'âŒ Deployment Failed' }} - ${{ github.repository }}"
          to: ${{ secrets.TESTER_EMAIL }}
          from: "CD Bot <${{ secrets.SMTP_USERNAME }}>"
          body:  |
            Hello Team,

            Deployment pipeline has completed. 

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ğŸ“‹ DEPLOYMENT DETAILS
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            ğŸ”¹ Status: ${{ needs.health-check.result == 'success' && 'âœ… SUCCESS' || 'âŒ FAILED' }}
            ğŸ”¹ Server: ${{ secrets.EC2_HOST }}
            ğŸ”¹ Application: ecommerce-frontend
            ğŸ”¹ Triggered by: ${{ github.actor }}

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ğŸ”— LINKS
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            ğŸŒ Application: http://${{ secrets.EC2_HOST }}: 3000
            ğŸ”„ Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            Regards,
            CD Bot ğŸ¤–
        continue-on-error: true